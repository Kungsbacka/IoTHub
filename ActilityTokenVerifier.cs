using IoTHub.Model;
using Microsoft.AspNetCore.Http;
using System;
using System.Security.Cryptography;
using System.Text;

namespace IoTHub
{

    public class ActilityTokenVerifier : IActilityTokenVerifier, IDisposable
    {
        private static ReadOnlySpan<byte> _hexLookup => new byte[]
        {
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 
        };
        private readonly SHA256 _sha256;
        private readonly StringBuilder _sb;
        private bool _disposed;

        public ActilityTokenVerifier()
        {
            _sha256 = SHA256.Create();
            _sb = new StringBuilder(250);
        }

        public bool IsTokenValid(ActilityUplinkData data, IQueryCollection query, string authenticationKey)
        {
            if (data == null)
            {
                throw new ArgumentNullException(nameof(data));
            }
            if (query == null)
            {
                throw new ArgumentNullException(nameof(query));
            }
            string token = query["Token"];
            if (string.IsNullOrEmpty(token) || token.Length != 64)
            {
                throw new ArgumentException("Invalid token");
            }

            _sb.Clear();

            // Add body elements
            _sb.Append(data.DevEUI_Uplink.CustomerID);
            _sb.Append(data.DevEUI_Uplink.DevEUI);
            _sb.Append(data.DevEUI_Uplink.FPort);
            _sb.Append(data.DevEUI_Uplink.FCntUp);
            _sb.Append(data.DevEUI_Uplink.Payload_Hex);

            // Add query string without token
            foreach (var kvp in query)
            {
                if (kvp.Key.Equals("Token", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }
                _sb.Append(kvp.Key);
                _sb.Append('=');
                _sb.Append(kvp.Value);
                _sb.Append('&');
            }
            _sb.Length--;

            // Add tunnel authentication key
            _sb.Append(authenticationKey);

            byte[] calculatedToken = _sha256.ComputeHash(Encoding.ASCII.GetBytes(_sb.ToString()));

            for (int i = 0; i < token.Length; i += 2)
            {
                byte b = (byte)(_hexLookup[(byte)token[i]] * 16 + _hexLookup[(byte)token[i + 1]]);
                if (b != calculatedToken[i / 2])
                {
                    return false;
                }
            }

            return true;
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    if (_sha256 != null)
                    {
                        _sha256.Dispose();
                    }
                }
                _disposed = true;
            }
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}
